# 数据库为什么普遍选择 B+ 树作为索引结构？

数据库的数据和索引通常存储在磁盘上。与内存相比，磁盘的读写速度要慢几个数量级。因此，**查询性能的关键瓶颈在于 I/O 次数**。

## B+ 树的几大优势

### 1. 矮胖的树形结构，I/O 次数极少

- 高扇出 (High Fan-out)：B+ 树是一个多路平衡查找树。与只有两个子节点的二叉树不同，B+ 树的一个节点可以拥有成百上千个子节点。
- 层高极低：由于扇出很高，树的层高（height）会非常低。例如，一个高度为 3 的 B+ 树就可以存储数千万条记录。
- 效果：查询一条数据时，从根节点到目标叶子节点最多只需要经过“树高”次 I/O 操作。如果树高是 3，那么最多只需要 3 次磁盘 I/O 就能定位到数据，速度极快。

### 2. 数据只存在于叶子节点，查询性能稳定

- B+ 树的非叶子节点（也叫内部节点）只存储索引键（Key）和指向下一层节点的指针，不存储具体的行数据。
- 所有的数据记录都完整地存放在叶子节点上。
- 效果：这意味着任何一次数据查询，其 I/O 路径长度都是相同的（都必须从根走到叶子），这使得查询性能非常稳定和可预测。

### 3. 叶子节点形成有序链表，对范围查询极其友好

- B+ 树的所有叶子节点之间通过指针串联成一个有序的双向链表。
- 效果：当执行范围查询（如 WHERE age > 20 AND age < 30）时，数据库首先通过树状结构快速定位到 age > 20 的第一个叶子节点，然后就可以沿着叶子节点的链表顺序向后扫描，直到不满足条件为止。这个过程是连续的磁盘读取，无需反复遍历树，效率极高。这是 B+ 树相比于 B 树、哈希索引等结构的一大杀手锏。

### 4. 完美匹配磁盘预读（Page/Block）

- 操作系统和数据库管理系统在从磁盘读取数据时，都不是按字节读取，而是按“页”（Page）或“块”（Block）来读取的，一页通常是 4KB、8KB 或 16KB。
- B+ 树的一个节点的大小通常被设计成与一个或多个页的大小相同。
- 效果：这意味着读取一个 B+ 树的节点，只需要一次 I/O 操作。由于内部节点存储了大量的键和指针，这次 I/O 读取到的信息量非常大，极大地提高了空间利用率和 I/O 效率。
- 因为页大小的限制，当记录过多时，树高也会因此增加，这也是为什么有人说MySQL最多只支持2000多万条记录的原因，此时层高由3层增加到4层，增加了一次磁盘 IO，并非MySQL不支持2000多万条记录。

## MySQL 的默认存储引擎 InnoDB 使用的是 B+ 树

但 InnoDB 的实现方式非常具有特色，它使用的是聚簇索引（Clustered Index）。

### 1. 主键索引 (Primary Key Index)

- InnoDB 的表数据本身就是按照主键的 B+ 树结构来组织的。
- B+ 树的叶子节点直接存储了完整的行数据。
- 这种“索引和数据合一”的结构就是聚簇索引。
  - 优点：通过主键查询时，只需要一次 B+ 树查找即可直接获取整行数据，速度极快。
  - 缺点：一张表只能有一个聚簇索引（因为数据只能有一种物理排序方式）。

### 2. 二级索引 (Secondary Index)

- 除了主键外的其他索引，比如你为 name 字段创建的索引，都属于二级索引。
- 二级索引的 B+ 树结构中，其叶子节点存储的不是行数据，而是该行记录的主键值。
- 查询过程：如果使用二级索引查询（如 WHERE name = 'Alice'），过程如下：
  1. 先在 name 索引的 B+ 树中找到 'Alice' 对应的叶子节点，获取其存储的主键值。
  2. 再拿着这个主键值，回到主键索引（聚簇索引）的 B+ 树中进行第二次查找。
  3. 最终在主键索引的叶子节点中找到完整的行数据。
- 这个过程被称为回表（Covering Index Lookups）。

**小结**：MySQL (InnoDB) 深度依赖 B+ 树，并以聚簇索引的方式将数据和主键索引组织在一起，二级索引则通过存储主键值来间接定位数据。

## PostgreSQL 的默认索引类型也是 B+ 树

PostgreSQL 的实现方式与 MySQL InnoDB 有着根本性的不同。

### 1. 无聚簇索引的概念（默认情况下）

- PostgreSQL 的表数据存储在一种称为 **堆表（Heap Table）** 的文件中，数据行的物理存储顺序与插入顺序或 VACUUM 操作有关，通常是无序的。
- 所有的索引，无论是主键索引还是其他索引，都与堆表分离。它们都是二级索引。

### 2. 索引结构

- PostgreSQL 的 B+ 树索引的叶子节点存储的是 (索引键, ctid) 对。
- ctid (Tuple Identifier) 是一个指向堆表中数据行物理位置的指针（可以理解为“页号 + 页内偏移量”）。
- 查询过程：任何通过索引的查询（即便是主键索引）都至少需要两步：
  1. 在 B+ 树索引中查找到对应的叶子节点，获取 ctid。
  2. 根据 ctid 直接去堆表文件中抓取完整的行数据。

**小结**：PostgreSQL 也使用 B+ 树，但其所有索引都与数据文件分离。索引存储指向物理数据行的指针 ctid，不存在 InnoDB 那样的“回表”概念，因为所有索引查找都天然需要一次额外的指针跳转来获取数据。
